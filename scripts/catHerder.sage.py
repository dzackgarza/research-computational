"""
Author: Galen Wilkerson
Date: 2024-08-06
Description: 
CatHerder is a simple and intuitive code creator and debugger that utilizes Large Language Model (LLM) reflection to help you debug Python code effectively. By iteratively refining code with the assistance of an LLM, this tool aims to make the debugging process smoother and more efficient.

You can also use it to gradually add features to existing code. This is where the cat herding really begins...
"""


# This file was *autogenerated* from the file ./catHerder.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_1 = Integer(1)
import os
import argparse
from openai import OpenAI
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configuration for local vs remote OpenAI
LOCAL_OPENAI_BASE_URL = os.getenv("OPENAI_BASE_URL", "http://127.0.0.1:1337/v1")
USE_LOCAL_OPENAI = os.getenv("USE_LOCAL_OPENAI", "true").lower() == "true"
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "not-needed-but-required")

past_errors = []
past_responses = []

import pickle

import traceback



def read_api_key(file_path):
    """
    Reads the API key from a specified file.

    Parameters:
    file_path (str): The path to the file containing the API key.

    Returns:
    str: The API key.
    """
    with open(file_path, 'r') as file:
        return file.read().strip()

def extract_code(response, code_type='sage'):
    """
    Extracts the code from the OpenAI API response based on the specified type.

    Parameters:
    response (dict): The response dictionary from the OpenAI API.
    code_type (str): The type of code block (default is 'sage').

    Returns:
    str: The extracted code.
    """
    # Extract the message content
    content = response['choices'][_sage_const_0 ]['message']['content']

    # Find the start and end of the code block
    start_tag = f"```{code_type}\n"
    start_index = content.find(start_tag) + len(start_tag)
    end_index = content.find("\n```", start_index)

    # Extract the code
    code = content[start_index:end_index]
    past_responses.append( (content, code) )
    with open('past_responses', 'wb') as fp:
        pickle.dump(past_responses, fp)
    return code

def call_chatgpt(prompt, client, code_type='sage', special_instructions='Implement a script in a single code block to perform this task: '):
    """
    Calls the OpenAI API to generate code based on the provided prompt.

    Parameters:
    prompt (str): The prompt describing the desired code.
    client (openai.OpenAI): The OpenAI client.
    code_type (str): The type of code block (default is 'sage').

    Returns:
    str: The generated code.
    """
    special_instructions = f"Implement a {code_type} script in a single code block to perform the following task. Please enclose all code in a single markdown code block, formatted in the following way: ```{code_type} ....(write code here).... ```. "
    response = client.chat.completions.create(
        model=OPENAI_MODEL,
        messages=[
            {"role": "system", 
            "content": """You are a research mathematician writing code for a peer-reviewed mathematical publication. Your goal is to implement the core mathematical ideas with complete conceptual clarity, rigorous correctness, and minimal but expressive syntax. Use exact arithmetic (e.g., rational numbers or symbolic algebra) where appropriate. Avoid heuristics, brute-force methods, or numerical approximations unless explicitly justified. Clearly separate definitions, lemmas, and computational tools. Favor canonical constructions and invariant-theoretic language. If a mathematical object (e.g., lattice, group, variety) has multiple equivalent representations, choose the one that best clarifies its structure and the logic of the argument.

Write code that reflects the structure of a clean proof, with readable notation matching standard mathematical conventions (e.g., inner products, duals, tensor products). Document only the nontrivial parts â€” assume the reader is mathematically sophisticated. Use libraries such as SageMath, GAP, Julia, Magma, or Macaulay2 depending on the context, and assume access to full symbolic computation tools.
             
Note that if an error says 'name xxxx is not defined', it likely references a non-existing function, class, or type. Refer to online programming documentation for replacements, and note that in Sage, this will likely not be resolved by jut an import statement.
When fixing code, ensure you are not reintroducing names shown not to exist in previous errors.
             """},
            {"role": "user", "content": special_instructions + prompt}
        ]
    )
    return extract_code(response.dict(), code_type=code_type)

def debug_code_with_chatgpt(original_prompt, code, error, client, code_type='sage'):
    """
    Calls the OpenAI API to debug the provided code based on the encountered error.

    Parameters:
    original_prompt (str): The original prompt describing the desired code.
    code (str): The code that produced an error.
    error (str): The error message.
    client (openai.OpenAI): The OpenAI client.
    code_type (str): The type of code block (default is 'sage').

    Returns:
    str: The suggested fix for the code.
    """
    global past_errors
    past_errors.append(error)
    prompt = f"The original prompt was:\n\n{original_prompt}\n\nHere is the code:\n\n{code}\n\nPlease help me fix it. Here is a list of past errors, please take all of them into account in your solution: " + "\n".join(past_errors)
    return call_chatgpt(prompt, client, code_type=code_type)

def save_code_to_file(code, code_type, iteration, status):
    """
    Saves the provided code to a specified file.

    Parameters:
    code (str): The code to be saved.
    code_type (str): The type of code (e.g., sage, latex, html).
    iteration (int): The iteration number of the code.
    status (str): The status of the code (e.g., iteration number or 'debugged').
    """
    # Ensure the scripts directory exists
    if not os.path.exists('./scripts'):
        os.makedirs('./scripts')

    # Determine the file extension based on the code type
    ext = 'sage' if code_type == 'sage' else code_type

    file_path = f"./scripts/script_{status}.{ext}"
    with open(file_path, 'w') as file:
        file.write(code)

def main():
    """
    Main function to read API key, generate code, and debug it iteratively.
    """
    parser = argparse.ArgumentParser(description='CatHerder: Reflective LLM Debugger')
    parser.add_argument('-p', '--prompt', type=str, help='The code prompt to generate new code or the path to a file containing the prompt', required=False)
    parser.add_argument('-m', '--modify', type=str, help='The path to the existing code file to modify', required=False)
    parser.add_argument('-c', '--code_type', type=str, default='sage', help='The type of code (default: sage, latex, html, etc.)')
    parser.add_argument('-i', '--iterations', type=int, default=_sage_const_5 , help='Number of debug iterations to perform (default: 5)')
    args = parser.parse_args()

    if not args.prompt and not args.modify:
        parser.print_usage()
        print("\nUsage Information:")
        print("  -p, --prompt: The code prompt to generate new code or the path to a file containing the prompt.")
        print("  -m, --modify: The path to the existing code file to modify.")
        print("  -c, --code_type: The type of code (default: sage, latex, html, etc.). Default is 'sage'.")
        print("  -i, --iterations: Number of debug iterations to perform. Default is 5.")
        print("\nEither a prompt or a path to modify an existing code file must be provided.")
        return

    # Configure OpenAI client for local or remote usage
    if USE_LOCAL_OPENAI:
        client = OpenAI(
            base_url=LOCAL_OPENAI_BASE_URL,
            api_key=OPENAI_API_KEY
        )
    else:
        # For remote OpenAI, try to read API key from file or environment
        api_key = OPENAI_API_KEY
        if api_key == "not-needed-but-required" and os.path.exists('api_key.txt'):
            api_key = read_api_key('api_key.txt')
        client = OpenAI(api_key=api_key)

    global past_errors
    global past_responses
    with open ('past_errors', 'rb') as fp:
        all_past_errs = pickle.load(fp)
        all_past_errs = list(set(all_past_errs))
        for er in all_past_errs:
            past_errors.append(er)

    with open ('past_responses', 'rb') as fp:
        all_past_responses = pickle.load(fp)
        for resp in all_past_responses:
            past_responses.append(all_past_responses)


    if args.prompt:
        if os.path.isfile(args.prompt):
            with open(args.prompt, 'r') as file:
                prompt = file.read()
        else:
            prompt = args.prompt
        code = call_chatgpt(prompt, client, args.code_type)
    elif args.modify:
        with open(args.modify, 'r') as file:
            code = file.read()
        prompt = input("Please describe the modifications you want to make: ")
        code = call_chatgpt(prompt, client, args.code_type, special_instructions='Modify the following code:\n\n' + code + '\n\n')

    if args.code_type == 'latex':
        save_code_to_file(code, args.code_type, _sage_const_0 , 'initial')
        print(f"Code saved to ./scripts/script_initial.{args.code_type}")
        return

    save_code_to_file(code, args.code_type, _sage_const_0 , 'initial')

    last_error_message = None

    for i in range(_sage_const_1 , args.iterations + _sage_const_1 ):
        print(f"\nIteration {i}:")

        try:
            if args.code_type in ['python', 'sage']:
                exec(code)
            else:
                print("Execution not supported for this code type in the current implementation.")
                print(code)
                break
            print("Code executed successfully.")
            save_code_to_file(code, args.code_type, i, 'debugged')
            print(f'Saved to ./scripts/script_debugged.{args.code_type}')
            break
        except Exception as e:
            error_message = traceback.format_exc()
            print("Error encountered:", error_message)

            last_error_message = error_message

            past_errors.append(error_message)
            past_errors = list(set(past_errors))
            with open('past_errors', 'wb') as fp:
                pickle.dump(past_errors, fp)

            
            # Get help from ChatGPT
            code = debug_code_with_chatgpt(args.prompt, code, error_message, client, args.code_type)

            save_code_to_file(code, args.code_type, i, f'iteration_{i}')

    # Save the last version of the code

    save_code_to_file(code, args.code_type, args.iterations, f'final')
    # Determine the file extension based on the code type
    ext = 'sage' if args.code_type == 'sage' else args.code_type
    print(f"Final version saved to ./scripts/script_final.{ext}")
    past_errors = list(set(past_errors))
    with open('past_errors', 'wb') as fp:
        pickle.dump(past_errors, fp)

if __name__ == "__main__":
    main()



